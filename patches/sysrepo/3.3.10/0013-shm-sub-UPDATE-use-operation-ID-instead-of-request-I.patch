From c1e13d121ee8f865f36c22a7765aff56b1229c5a Mon Sep 17 00:00:00 2001
From: Michal Vasko <mvasko@cesnet.cz>
Date: Tue, 14 Jan 2025 13:35:28 +0100
Subject: [PATCH 13/22] shm sub UPDATE use operation ID instead of request ID
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Organization: Addiva Elektronik

... which can be used to connect various callback
calls that are part of a single operation.

Signed-off-by: Mattias Walstr√∂m <lazzer@gmail.com>
---
 src/common.c           |   8 +-
 src/common.h           |   7 +-
 src/modinfo.c          |  27 +++---
 src/modinfo.h          |   1 +
 src/shm_main.c         |   1 +
 src/shm_sub.c          | 202 ++++++++++++++++++++++-------------------
 src/shm_sub.h          |  27 +++---
 src/shm_types.h        |   4 +-
 src/sysrepo.c          |  72 +++++++--------
 src/sysrepo_types.h    |  17 ++--
 tests/test_oper_pull.c |   3 +-
 11 files changed, 202 insertions(+), 167 deletions(-)

diff --git a/src/common.c b/src/common.c
index 72f3fc93..af607557 100644
--- a/src/common.c
+++ b/src/common.c
@@ -2890,7 +2890,7 @@ sr_conn_ext_data_update(sr_conn_ctx_t *conn)
     struct lyd_node *yl_data = NULL, *new_ext_data = NULL;
 
     /* init mod info for cleanup */
-    SR_MODINFO_INIT(mi, conn, SR_DS_OPERATIONAL, SR_DS_RUNNING);
+    SR_MODINFO_INIT(mi, conn, SR_DS_OPERATIONAL, SR_DS_RUNNING, 0);
 
     /* manually get ietf-yang-schema-mount operational data but avoid recursive call of this function */
     ly_mod = ly_ctx_get_module_implemented(conn->ly_ctx, "ietf-yang-schema-mount");
@@ -5609,6 +5609,7 @@ sr_generate_notif_send(sr_conn_ctx_t *conn, sr_mod_t *shm_mod, const struct lyd_
 {
     sr_error_info_t *err_info = NULL;
     struct timespec notif_ts_mono, notif_ts_real;
+    uint32_t operation_id;
 
     /* NOTIF SUB READ LOCK */
     if ((err_info = sr_rwlock(&shm_mod->notif_lock, SR_SHMEXT_SUB_LOCK_TIMEOUT, SR_LOCK_READ, conn->cid,
@@ -5620,8 +5621,11 @@ sr_generate_notif_send(sr_conn_ctx_t *conn, sr_mod_t *shm_mod, const struct lyd_
     sr_timeouttime_get(&notif_ts_mono, 0);
     sr_realtime_get(&notif_ts_real);
 
+    /* generate a new operation ID */
+    operation_id = ATOMIC_INC_RELAXED(SR_CONN_MAIN_SHM(conn)->new_operation_id);
+
     /* send the notification (non-validated, must be valid) */
-    err_info = sr_shmsub_notif_notify(conn, notif, notif_ts_mono, notif_ts_real, NULL, NULL, 0, 0);
+    err_info = sr_shmsub_notif_notify(conn, notif, notif_ts_mono, notif_ts_real, NULL, NULL, operation_id, 0, 0);
 
     /* NOTIF SUB READ UNLOCK */
     sr_rwunlock(&shm_mod->notif_lock, SR_SHMEXT_SUB_LOCK_TIMEOUT, SR_LOCK_READ, conn->cid, __func__);
diff --git a/src/common.h b/src/common.h
index 9fc675d4..f6bc9128 100644
--- a/src/common.h
+++ b/src/common.h
@@ -189,7 +189,12 @@ extern const sr_module_ds_t sr_module_ds_disabled_run;
 #define SR_SHM_INITIALIZER {.fd = -1, .size = 0, .addr = NULL}
 
 /** initializer of mod_info structure */
-#define SR_MODINFO_INIT(mi, c, d, d2) memset(&(mi), 0, sizeof (mi)); (mi).ds = (d); (mi).ds2 = (d2); (mi).conn = (c)
+#define SR_MODINFO_INIT(mi, c, d, d2, op_id) \
+        memset(&(mi), 0, sizeof (mi)); \
+        (mi).ds = (d); \
+        (mi).ds2 = (d2); \
+        (mi).conn = (c); \
+        (mi).operation_id = (op_id) ? (op_id) : ATOMIC_INC_RELAXED(SR_CONN_MAIN_SHM(c)->new_operation_id)
 
 /**
  * @brief Internal information about a module to be installed.
diff --git a/src/modinfo.c b/src/modinfo.c
index f969f363..d002bbdb 100644
--- a/src/modinfo.c
+++ b/src/modinfo.c
@@ -1053,6 +1053,7 @@ cleanup:
  * @param[in] req_xpath_count Count of @p request_xpaths.
  * @param[in] orig_name Event originator name.
  * @param[in] orig_data Event originator data.
+ * @param[in] operation_id Operation ID.
  * @param[in] shm_subs Subscription array.
  * @param[in] idx1 Index of the subscription array from where to read subscriptions with the same XPath.
  * @param[in] parent Data parent required for the subscription, NULL if top-level.
@@ -1063,9 +1064,9 @@ cleanup:
  */
 static sr_error_info_t *
 sr_xpath_oper_data_get(struct sr_mod_info_mod_s *mod, const char *xpath, const char **request_xpaths,
-        uint32_t req_xpath_count, const char *orig_name, const void *orig_data, sr_mod_oper_get_sub_t *shm_subs,
-        uint32_t idx1, const struct lyd_node *parent, uint32_t timeout_ms, sr_conn_ctx_t *conn,
-        struct lyd_node **oper_data)
+        uint32_t req_xpath_count, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        sr_mod_oper_get_sub_t *shm_subs, uint32_t idx1, const struct lyd_node *parent, uint32_t timeout_ms,
+        sr_conn_ctx_t *conn, struct lyd_node **oper_data)
 {
     sr_error_info_t *err_info = NULL, *cb_err_info = NULL;
     struct lyd_node *parent_dup = NULL, *last_parent;
@@ -1108,8 +1109,8 @@ sr_xpath_oper_data_get(struct sr_mod_info_mod_s *mod, const char *xpath, const c
     request_xpath = (req_xpath_count == 1) ? request_xpaths[0] : NULL;
 
     /* get data from client */
-    if ((err_info = sr_shmsub_oper_get_notify(mod, xpath, request_xpath, parent_dup, orig_name, orig_data, shm_subs,
-            idx1, timeout_ms, conn, oper_data, &cb_err_info))) {
+    if ((err_info = sr_shmsub_oper_get_notify(mod, xpath, request_xpath, parent_dup, orig_name, orig_data, operation_id,
+            shm_subs, idx1, timeout_ms, conn, oper_data, &cb_err_info))) {
         sr_errinfo_merge(&err_info, cb_err_info);
         goto cleanup;
     }
@@ -1431,6 +1432,7 @@ cleanup:
  * @param[in] oper_mode Current lock mode of @p mod for ::SR_DS_OPERATIONAL.
  * @param[in] orig_name Event originator name.
  * @param[in] orig_data Event originator data.
+ * @param[in] operation_id Operation ID.
  * @param[in] conn Connection to use.
  * @param[in] timeout_ms Operational callback timeout in milliseconds.
  * @param[in] get_oper_opts Get oper data options.
@@ -1438,8 +1440,9 @@ cleanup:
  * @return err_info, NULL on success.
  */
 static sr_error_info_t *
-sr_module_oper_data_update(struct sr_mod_info_mod_s *mod, const char *orig_name, const void *orig_data, sr_conn_ctx_t *conn,
-        uint32_t timeout_ms, sr_get_oper_flag_t get_oper_opts, struct lyd_node **data)
+sr_module_oper_data_update(struct sr_mod_info_mod_s *mod, const char *orig_name, const void *orig_data,
+        uint32_t operation_id, sr_conn_ctx_t *conn, uint32_t timeout_ms, sr_get_oper_flag_t get_oper_opts,
+        struct lyd_node **data)
 {
     sr_error_info_t *err_info = NULL;
     sr_mod_oper_get_sub_t *shm_subs;
@@ -1554,7 +1557,7 @@ sr_module_oper_data_update(struct sr_mod_info_mod_s *mod, const char *orig_name,
             for (j = 0; j < set->count; ++j) {
                 /* get oper data from the client */
                 if ((err_info = sr_xpath_oper_data_get(mod, sub_xpath, request_xpaths, req_xpath_count, orig_name,
-                        orig_data, shm_subs, i, set->dnodes[j], timeout_ms, conn, &oper_data))) {
+                        orig_data, operation_id, shm_subs, i, set->dnodes[j], timeout_ms, conn, &oper_data))) {
                     goto cleanup_opergetsub_ext_unlock;
                 }
 
@@ -1574,7 +1577,7 @@ next_iter:
         } else {
             /* top-level data */
             if ((err_info = sr_xpath_oper_data_get(mod, sub_xpath, request_xpaths, req_xpath_count, orig_name,
-                    orig_data, shm_subs, i, NULL, timeout_ms, conn, &oper_data))) {
+                    orig_data, operation_id, shm_subs, i, NULL, timeout_ms, conn, &oper_data))) {
                 goto cleanup_opergetsub_ext_unlock;
             }
 
@@ -2774,8 +2777,8 @@ sr_modinfo_module_data_load(struct sr_mod_info_s *mod_info, struct sr_mod_info_m
         }
 
         /* append any operational data provided by clients */
-        if ((err_info = sr_module_oper_data_update(mod, orig_name, orig_data, conn, timeout_ms, get_oper_opts,
-                &mod_info->data))) {
+        if ((err_info = sr_module_oper_data_update(mod, orig_name, orig_data, mod_info->operation_id, conn, timeout_ms,
+                get_oper_opts, &mod_info->data))) {
             return err_info;
         }
     }
@@ -3811,7 +3814,7 @@ sr_modinfo_generate_config_change_notif(struct sr_mod_info_s *mod_info, sr_sessi
 
     /* send the notification (non-validated, if everything works correctly it must be valid) */
     err_info = sr_shmsub_notif_notify(mod_info->conn, notif, notif_ts_mono, notif_ts_real, session->orig_name,
-            session->orig_data, 0, 0);
+            session->orig_data, mod_info->operation_id, 0, 0);
 
     /* NOTIF SUB READ UNLOCK */
     sr_rwunlock(&shm_mod->notif_lock, SR_SHMEXT_SUB_LOCK_TIMEOUT, SR_LOCK_READ, mod_info->conn->cid, __func__);
diff --git a/src/modinfo.h b/src/modinfo.h
index 1b82300e..b8108f8e 100644
--- a/src/modinfo.h
+++ b/src/modinfo.h
@@ -50,6 +50,7 @@ struct sr_mod_info_s {
     struct lyd_node *data;      /**< Data tree. */
     int data_cached;            /**< Whether the data are actually cached. */
     sr_conn_ctx_t *conn;        /**< Associated connection. */
+    uint32_t operation_id;      /**< ID of the current operation for all the callbacks. */
 
     struct sr_mod_info_mod_s {
         sr_mod_t *shm_mod;      /**< Module SHM structure. */
diff --git a/src/shm_main.c b/src/shm_main.c
index 4b273b49..fdcb567b 100644
--- a/src/shm_main.c
+++ b/src/shm_main.c
@@ -509,6 +509,7 @@ sr_shmmain_open(sr_shm_t *shm, int *created)
         ATOMIC_STORE_RELAXED(main_shm->new_sr_sid, 1);
         ATOMIC_STORE_RELAXED(main_shm->new_sub_id, 1);
         ATOMIC_STORE_RELAXED(main_shm->new_evpipe_num, 1);
+        ATOMIC_STORE_RELAXED(main_shm->new_operation_id, 1);
         strncpy(main_shm->repo_path, sr_get_repo_path(), sizeof main_shm->repo_path - 1);
 
         /* remove leftover event pipes */
diff --git a/src/shm_sub.c b/src/shm_sub.c
index babeaa0c..fd6f105b 100644
--- a/src/shm_sub.c
+++ b/src/shm_sub.c
@@ -4,8 +4,8 @@
  * @brief subscription SHM routines
  *
  * @copyright
- * Copyright (c) 2018 - 2023 Deutsche Telekom AG.
- * Copyright (c) 2018 - 2023 CESNET, z.s.p.o.
+ * Copyright (c) 2018 - 2025 Deutsche Telekom AG.
+ * Copyright (c) 2018 - 2025 CESNET, z.s.p.o.
  *
  * This source code is licensed under BSD 3-Clause License (the "License").
  * You may not use this file except in compliance with the License.
@@ -451,6 +451,7 @@ event_handled:
  *              ::SR_SUB_EV_ERROR - an answer is expected and SHM will be further accessed so do not clear any events.
  * @param[in] clear_ev_on_err Whether to clear the current event if error/timeout occurs or leave it be.
  * @param[in] cid Connection ID.
+ * @param[in] operation_id Operation ID.
  * @param[in] shm_data_sub Opened sub data SHM.
  * @param[in] timeout_abs Absolute timeout for the event to be handled.
  * @param[out] lock_lost Set if the WRITE lock was released, possible only if err_info is returned.
@@ -459,8 +460,8 @@ event_handled:
  */
 static sr_error_info_t *
 _sr_shmsub_notify_wait_wr(sr_sub_shm_t *sub_shm, sr_sub_event_t event, uint32_t request_id, sr_sub_event_t expected_ev,
-        int clear_ev_on_err, sr_cid_t cid, sr_shm_t *shm_data_sub, struct timespec *timeout_abs, int *lock_lost,
-        sr_error_info_t **cb_err_info)
+        int clear_ev_on_err, sr_cid_t cid, uint32_t operation_id, sr_shm_t *shm_data_sub, struct timespec *timeout_abs,
+        int *lock_lost, sr_error_info_t **cb_err_info)
 {
     sr_error_info_t *err_info = NULL;
     sr_error_t err_code;
@@ -509,14 +510,14 @@ _sr_shmsub_notify_wait_wr(sr_sub_shm_t *sub_shm, sr_sub_event_t event, uint32_t
             if (!(err_info = sr_sub_rwlock(&sub_shm->lock, &timeout_abs2, SR_LOCK_WRITE, cid, __func__, NULL, NULL, 1))) {
                 /* event timeout */
                 sr_errinfo_new(cb_err_info, SR_ERR_TIME_OUT, "EV ORIGIN: SHM event \"%s\" ID %" PRIu32 " processing timed out.",
-                        sr_ev2str(event), request_id);
+                        sr_ev2str(event), operation_id);
                 write_lock = 1;
             }
         } else {
             /* other error - not ETIMEDOUT or shm event has changed incorrectly */
             if (event != last_event) {
                 SR_LOG_WRN("EV ORIGIN: SHM event \"%s\" ID %" PRIu32 " changed to \"%s\" unexpectedly",
-                        sr_ev2str(event), request_id, sr_ev2str(last_event));
+                        sr_ev2str(event), operation_id, sr_ev2str(last_event));
 
             }
             SR_ERRINFO_COND(&err_info, __func__, ret);
@@ -650,6 +651,7 @@ event_handled:
  *              ::SR_SUB_EV_ERROR - an answer is expected and SHM will be further accessed so do not clear any events.
  * @param[in] clear_ev_on_err Whether to clear the current event if error/timeout occurs or leave it be.
  * @param[in] cid Connection ID.
+ * @param[in] operation_id Operation ID.
  * @param[in] shm_data_sub Opened sub data SHM.
  * @param[in] timeout_ms Timeout in milliseconds.
  * @param[out] lock_lost Set if the WRITE lock was released, possible only if err_info is returned.
@@ -658,7 +660,7 @@ event_handled:
  */
 static sr_error_info_t *
 sr_shmsub_notify_wait_wr(sr_sub_shm_t *sub_shm, sr_sub_event_t expected_ev, int clear_ev_on_err, sr_cid_t cid,
-        sr_shm_t *shm_data_sub, uint32_t timeout_ms, int *lock_lost, sr_error_info_t **cb_err_info)
+        uint32_t operation_id, sr_shm_t *shm_data_sub, uint32_t timeout_ms, int *lock_lost, sr_error_info_t **cb_err_info)
 {
     sr_sub_event_t event;
     uint32_t request_id;
@@ -671,8 +673,8 @@ sr_shmsub_notify_wait_wr(sr_sub_shm_t *sub_shm, sr_sub_event_t expected_ev, int
     /* compute the timeout */
     sr_timeouttime_get(&timeout_abs, timeout_ms);
 
-    return _sr_shmsub_notify_wait_wr(sub_shm, event, request_id, expected_ev, clear_ev_on_err, cid, shm_data_sub,
-            &timeout_abs, lock_lost, cb_err_info);
+    return _sr_shmsub_notify_wait_wr(sub_shm, event, request_id, expected_ev, clear_ev_on_err, cid, operation_id,
+            shm_data_sub, &timeout_abs, lock_lost, cb_err_info);
 }
 
 /**
@@ -693,12 +695,13 @@ sr_shmsub_notify_wait_wr(sr_sub_shm_t *sub_shm, sr_sub_event_t expected_ev, int
  *              ::SR_SUB_EV_ERROR - an answer is expected and SHM will be further accessed so do not clear any events.
  * @param[in] clear_ev_on_err Whether to clear the current event if error/timeout occurs or leave it be.
  * @param[in] cid Connection ID.
+ * @param[in] operation_id Operation ID.
  * @param[in] timeout_ms Timeout in milliseconds.
  * @return err_info, NULL on success.
  */
 static sr_error_info_t *
 sr_shmsub_notify_many_wait_wr(struct sr_shmsub_many_info_s *notify_subs, uint32_t notify_size, uint32_t notify_count,
-        sr_sub_event_t expected_ev, int clear_ev_on_err, sr_cid_t cid, uint32_t timeout_ms)
+        sr_sub_event_t expected_ev, int clear_ev_on_err, sr_cid_t cid, uint32_t operation_id, uint32_t timeout_ms)
 {
     sr_error_info_t *err_info = NULL, *tmp_err;
     struct sr_shmsub_many_info_s *nsub;
@@ -756,7 +759,7 @@ sr_shmsub_notify_many_wait_wr(struct sr_shmsub_many_info_s *notify_subs, uint32_
 
         /* wait for an event change */
         tmp_err = _sr_shmsub_notify_wait_wr(nsub->sub_shm, nsub->event, nsub->request_id, expected_ev, clear_ev_on_err,
-                cid, &nsub->shm_data_sub, &timeout_abs, &lock_lost, &nsub->cb_err_info);
+                cid, operation_id, &nsub->shm_data_sub, &timeout_abs, &lock_lost, &nsub->cb_err_info);
         if (tmp_err) {
             if (lock_lost) {
                 /* WRITE lock lost */
@@ -785,6 +788,7 @@ sr_shmsub_notify_many_wait_wr(struct sr_shmsub_many_info_s *notify_subs, uint32_
  * @param[in] orig_name Originator name.
  * @param[in] orig_data Originator data.
  * @param[in] subscriber_count Subscriber count.
+ * @param[in] operation_id Operation ID.
  * @param[in] shm_data_sub Opened sub data SHM.
  * @param[in] xpath Optional XPath written into sub data SHM.
  * @param[in] data Optional data written into sub data SHM.
@@ -795,7 +799,8 @@ sr_shmsub_notify_many_wait_wr(struct sr_shmsub_many_info_s *notify_subs, uint32_
 static sr_error_info_t *
 sr_shmsub_notify_write_event(sr_sub_shm_t *sub_shm, sr_cid_t orig_cid, uint32_t request_id, uint32_t priority,
         sr_sub_event_t event, const char *orig_name, const void *orig_data, uint32_t subscriber_count,
-        sr_shm_t *shm_data_sub, const char *xpath, const char *data, uint32_t data_len, const char *event_desc)
+        uint32_t operation_id, sr_shm_t *shm_data_sub, const char *xpath, const char *data, uint32_t data_len,
+        const char *event_desc)
 {
     sr_error_info_t *err_info = NULL;
     char *shm_data_ptr = NULL;
@@ -817,6 +822,7 @@ sr_shmsub_notify_write_event(sr_sub_shm_t *sub_shm, sr_cid_t orig_cid, uint32_t
     ATOMIC_STORE_RELAXED(sub_shm->event, event);
     ATOMIC_STORE_RELAXED(sub_shm->priority, priority);
     sub_shm->subscriber_count = subscriber_count;
+    sub_shm->operation_id = operation_id;
 
     /* remap if needed */
     if (xpath || data_len) {
@@ -848,7 +854,7 @@ sr_shmsub_notify_write_event(sr_sub_shm_t *sub_shm, sr_cid_t orig_cid, uint32_t
 
     if (event && event_desc) {
         SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " for %" PRIu32 " subscribers published.",
-                event_desc, sr_ev2str(event), request_id, priority, subscriber_count);
+                event_desc, sr_ev2str(event), operation_id, priority, subscriber_count);
     }
     return NULL;
 }
@@ -1354,8 +1360,8 @@ sr_shmsub_change_notify_update(struct sr_mod_info_s *mod_info, const char *orig_
                 mod->request_id = ++sub_shm->request_id;
             }
             if ((err_info = sr_shmsub_notify_write_event(sub_shm, cid, mod->request_id, cur_priority,
-                    SR_SUB_EV_UPDATE, orig_name, orig_data, subscriber_count, &shm_data_sub, NULL, diff_lyb,
-                    diff_lyb_len, mod->ly_mod->name))) {
+                    SR_SUB_EV_UPDATE, orig_name, orig_data, subscriber_count, mod_info->operation_id,  &shm_data_sub,
+                    NULL, diff_lyb, diff_lyb_len, mod->ly_mod->name))) {
                 goto cleanup_wrunlock;
             }
 
@@ -1370,8 +1376,8 @@ sr_shmsub_change_notify_update(struct sr_mod_info_s *mod_info, const char *orig_
             }
 
             /* wait until the event is processed */
-            if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_ERROR, 0, cid, &shm_data_sub, timeout_ms,
-                    &lock_lost, cb_err_info))) {
+            if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_ERROR, 0, cid, mod_info->operation_id,
+                    &shm_data_sub, timeout_ms, &lock_lost, cb_err_info))) {
                 if (lock_lost) {
                     goto cleanup;
                 } else {
@@ -1382,11 +1388,12 @@ sr_shmsub_change_notify_update(struct sr_mod_info_s *mod_info, const char *orig_
             if (*cb_err_info) {
                 /* failed callback or timeout */
                 SR_LOG_WRN("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " failed (%s).", mod->ly_mod->name,
-                        sr_ev2str(SR_SUB_EV_UPDATE), mod->request_id, cur_priority, sr_strerror((*cb_err_info)->err[0].err_code));
+                        sr_ev2str(SR_SUB_EV_UPDATE), mod_info->operation_id, cur_priority,
+                        sr_strerror((*cb_err_info)->err[0].err_code));
                 goto cleanup_wrunlock;
             } else {
                 SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " succeeded.", mod->ly_mod->name,
-                        sr_ev2str(SR_SUB_EV_UPDATE), mod->request_id, cur_priority);
+                        sr_ev2str(SR_SUB_EV_UPDATE), mod_info->operation_id, cur_priority);
             }
 
             assert(sub_shm->event == SR_SUB_EV_SUCCESS);
@@ -1482,7 +1489,7 @@ sr_shmsub_change_notify_clear(struct sr_mod_info_s *mod_info)
 
             /* clear it */
             if ((err_info = sr_shmsub_notify_write_event(sub_shm, 0, mod->request_id, sub_shm->priority, 0, NULL, NULL,
-                    0, NULL, NULL, NULL, 0, NULL))) {
+                    0, mod_info->operation_id, NULL, NULL, NULL, 0, NULL))) {
                 goto cleanup_wrunlock;
             }
 
@@ -1659,8 +1666,8 @@ sr_shmsub_change_notify_change(struct sr_mod_info_s *mod_info, const char *orig_
                 nsub->mod->request_id = ++nsub->sub_shm->request_id;
             }
             if ((err_info = sr_shmsub_notify_write_event((sr_sub_shm_t *)nsub->shm_sub.addr, cid, nsub->mod->request_id,
-                    nsub->cur_priority, SR_SUB_EV_CHANGE, orig_name, orig_data, subscriber_count, &nsub->shm_data_sub,
-                    NULL, diff_lyb, diff_lyb_len, nsub->mod->ly_mod->name))) {
+                    nsub->cur_priority, SR_SUB_EV_CHANGE, orig_name, orig_data, subscriber_count, mod_info->operation_id,
+                    &nsub->shm_data_sub, NULL, diff_lyb, diff_lyb_len, nsub->mod->ly_mod->name))) {
                 goto cleanup;
             }
 
@@ -1696,7 +1703,7 @@ sr_shmsub_change_notify_change(struct sr_mod_info_s *mod_info, const char *orig_
 
         /* wait until the events are processed */
         if ((err_info = sr_shmsub_notify_many_wait_wr((struct sr_shmsub_many_info_s *)notify_subs, sizeof *notify_subs,
-                notify_count, SR_SUB_EV_SUCCESS, 0, cid, timeout_ms))) {
+                notify_count, SR_SUB_EV_SUCCESS, 0, cid, mod_info->operation_id, timeout_ms))) {
             goto cleanup;
         }
 
@@ -1715,7 +1722,7 @@ sr_shmsub_change_notify_change(struct sr_mod_info_s *mod_info, const char *orig_
             if (nsub->cb_err_info) {
                 /* failed callback or timeout */
                 SR_LOG_WRN("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " failed (%s).",
-                        nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_CHANGE), nsub->mod->request_id, nsub->cur_priority,
+                        nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_CHANGE), mod_info->operation_id, nsub->cur_priority,
                         sr_strerror(nsub->cb_err_info->err[0].err_code));
 
                 /* merge the error */
@@ -1723,7 +1730,7 @@ sr_shmsub_change_notify_change(struct sr_mod_info_s *mod_info, const char *orig_
                 nsub->cb_err_info = NULL;
             } else {
                 SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " succeeded.",
-                        nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_CHANGE), nsub->mod->request_id, nsub->cur_priority);
+                        nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_CHANGE), mod_info->operation_id, nsub->cur_priority);
             }
             nsub->pending_event = 0;
         }
@@ -1852,8 +1859,8 @@ sr_shmsub_change_notify_change_done(struct sr_mod_info_s *mod_info, const char *
                 nsub->mod->request_id = ++nsub->sub_shm->request_id;
             }
             if ((err_info = sr_shmsub_notify_write_event((sr_sub_shm_t *)nsub->shm_sub.addr, cid, nsub->mod->request_id,
-                    nsub->cur_priority, SR_SUB_EV_DONE, orig_name, orig_data, subscriber_count, &nsub->shm_data_sub,
-                    NULL, diff_lyb, diff_lyb_len, nsub->mod->ly_mod->name))) {
+                    nsub->cur_priority, SR_SUB_EV_DONE, orig_name, orig_data, subscriber_count, mod_info->operation_id,
+                    &nsub->shm_data_sub, NULL, diff_lyb, diff_lyb_len, nsub->mod->ly_mod->name))) {
                 goto cleanup;
             }
 
@@ -1888,7 +1895,7 @@ sr_shmsub_change_notify_change_done(struct sr_mod_info_s *mod_info, const char *
 
         /* wait until the events are processed */
         if ((err_info = sr_shmsub_notify_many_wait_wr((struct sr_shmsub_many_info_s *)notify_subs, sizeof *notify_subs,
-                notify_count, SR_SUB_EV_FINISHED, 1, cid, timeout_ms))) {
+                notify_count, SR_SUB_EV_FINISHED, 1, cid, mod_info->operation_id, timeout_ms))) {
             goto cleanup;
         }
 
@@ -1908,7 +1915,7 @@ sr_shmsub_change_notify_change_done(struct sr_mod_info_s *mod_info, const char *
             sr_errinfo_free(&nsub->cb_err_info);
 
             SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " succeeded.",
-                    nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_DONE), nsub->mod->request_id, nsub->cur_priority);
+                    nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_DONE), mod_info->operation_id, nsub->cur_priority);
 
             nsub->pending_event = 0;
         }
@@ -2017,8 +2024,8 @@ sr_shmsub_change_notify_change_abort(struct sr_mod_info_s *mod_info, const char
 
             /* clear the error */
             assert(nsub->sub_shm->request_id == nsub->mod->request_id);
-            if ((err_info = sr_shmsub_notify_write_event(sub_shm, 0, nsub->mod->request_id,
-                    nsub->cur_priority, 0, NULL, NULL, 0, &nsub->shm_data_sub, NULL, NULL, 0, NULL))) {
+            if ((err_info = sr_shmsub_notify_write_event(sub_shm, 0, nsub->mod->request_id, nsub->cur_priority, 0, NULL,
+                    NULL, 0, mod_info->operation_id, &nsub->shm_data_sub, NULL, NULL, 0, NULL))) {
                 goto cleanup;
             }
         }
@@ -2094,8 +2101,8 @@ sr_shmsub_change_notify_change_abort(struct sr_mod_info_s *mod_info, const char
 
             /* write the event */
             if ((err_info = sr_shmsub_notify_write_event(sub_shm, cid, nsub->mod->request_id, nsub->cur_priority,
-                    SR_SUB_EV_ABORT, orig_name, orig_data, subscriber_count, &nsub->shm_data_sub, NULL, diff_lyb,
-                    diff_lyb_len, nsub->mod->ly_mod->name))) {
+                    SR_SUB_EV_ABORT, orig_name, orig_data, subscriber_count, mod_info->operation_id, &nsub->shm_data_sub,
+                    NULL, diff_lyb, diff_lyb_len, nsub->mod->ly_mod->name))) {
                 goto cleanup;
             }
 
@@ -2130,7 +2137,7 @@ sr_shmsub_change_notify_change_abort(struct sr_mod_info_s *mod_info, const char
 
         /* wait until the events are processed */
         if ((err_info = sr_shmsub_notify_many_wait_wr((struct sr_shmsub_many_info_s *)notify_subs, sizeof *notify_subs,
-                notify_count, SR_SUB_EV_FINISHED, 1, cid, timeout_ms))) {
+                notify_count, SR_SUB_EV_FINISHED, 1, cid, mod_info->operation_id, timeout_ms))) {
             goto cleanup;
         }
 
@@ -2150,7 +2157,7 @@ sr_shmsub_change_notify_change_abort(struct sr_mod_info_s *mod_info, const char
             sr_errinfo_free(&nsub->cb_err_info);
 
             SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " succeeded.",
-                    nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_ABORT), nsub->mod->request_id, nsub->cur_priority);
+                    nsub->mod->ly_mod->name, sr_ev2str(SR_SUB_EV_ABORT), mod_info->operation_id, nsub->cur_priority);
 
             nsub->pending_event = 0;
         }
@@ -2183,8 +2190,9 @@ cleanup:
 
 sr_error_info_t *
 sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const char *xpath, const char *request_xpath,
-        const struct lyd_node *parent, const char *orig_name, const void *orig_data, sr_mod_oper_get_sub_t *oper_get_subs,
-        uint32_t idx1, uint32_t timeout_ms, sr_conn_ctx_t *conn, struct lyd_node **data, sr_error_info_t **cb_err_info)
+        const struct lyd_node *parent, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        sr_mod_oper_get_sub_t *oper_get_subs, uint32_t idx1, uint32_t timeout_ms, sr_conn_ctx_t *conn,
+        struct lyd_node **data, sr_error_info_t **cb_err_info)
 {
     sr_error_info_t *err_info = NULL;
     uint32_t i, notify_count = 0, parent_lyb_len, request_id;
@@ -2257,11 +2265,11 @@ sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const char *xpath, cons
         /* write the request for state data */
         request_id = ATOMIC_LOAD_RELAXED(nsub->sub_shm->request_id) + 1;
         if ((err_info = sr_shmsub_notify_write_event(nsub->sub_shm, cid, request_id, 0, SR_SUB_EV_OPER, orig_name,
-                orig_data, 1, &nsub->shm_data_sub, request_xpath, parent_lyb, parent_lyb_len, NULL))) {
+                orig_data, 1, operation_id, &nsub->shm_data_sub, request_xpath, parent_lyb, parent_lyb_len, NULL))) {
             goto cleanup;
         }
         SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" index %" PRIu32 " ID %" PRIu32 " published.", xpath,
-                sr_ev2str(SR_SUB_EV_OPER), i, request_id);
+                sr_ev2str(SR_SUB_EV_OPER), i, operation_id);
 
         /* notify using event pipe */
         if ((err_info = sr_shmsub_notify_evpipe(nsub->xpath_sub->evpipe_num))) {
@@ -2273,7 +2281,7 @@ sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const char *xpath, cons
 
     /* wait until the events are processed */
     if ((err_info = sr_shmsub_notify_many_wait_wr((struct sr_shmsub_many_info_s *)notify_subs, sizeof *notify_subs,
-            notify_count, SR_SUB_EV_ERROR, 1, cid, timeout_ms))) {
+            notify_count, SR_SUB_EV_ERROR, 1, cid, operation_id, timeout_ms))) {
         goto cleanup;
     }
 
@@ -2286,7 +2294,7 @@ sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const char *xpath, cons
         if (nsub->cb_err_info) {
             /* failed callback */
             SR_LOG_WRN("EV ORIGIN: \"%s\" \"%s\" index %" PRIu32 " ID %" PRIu32 " failed (%s).", xpath,
-                    sr_ev2str(SR_SUB_EV_OPER), i, nsub->request_id, sr_strerror(nsub->cb_err_info->err[0].err_code));
+                    sr_ev2str(SR_SUB_EV_OPER), i, operation_id, sr_strerror(nsub->cb_err_info->err[0].err_code));
 
             /* merge the error and continue */
             sr_errinfo_merge(cb_err_info, nsub->cb_err_info);
@@ -2295,7 +2303,7 @@ sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const char *xpath, cons
             continue;
         } else {
             SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" index %" PRIu32 " ID %" PRIu32 " succeeded.", xpath,
-                    sr_ev2str(SR_SUB_EV_OPER), i, nsub->request_id);
+                    sr_ev2str(SR_SUB_EV_OPER), i, operation_id);
         }
 
         assert(ATOMIC_LOAD_RELAXED(nsub->sub_shm->event) == SR_SUB_EV_SUCCESS);
@@ -2348,11 +2356,13 @@ cleanup:
  *
  * @param[in] conn Connection to use.
  * @param[in] input Input tree pointing to the operation node.
+ * @param[in] operation_id Operation ID.
  * @param[out] output Output tree pointing to the operation node.
  * @return err_info, NULL on success.
  */
 static sr_error_info_t *
-sr_shmsub_rpc_internal_call_callback(sr_conn_ctx_t *conn, const struct lyd_node *input, struct lyd_node **output)
+sr_shmsub_rpc_internal_call_callback(sr_conn_ctx_t *conn, const struct lyd_node *input, uint32_t operation_id,
+        struct lyd_node **output)
 {
     sr_error_info_t *err_info = NULL, *cb_err_info = NULL;
     struct sr_mod_info_s mod_info;
@@ -2365,7 +2375,7 @@ sr_shmsub_rpc_internal_call_callback(sr_conn_ctx_t *conn, const struct lyd_node
 
     assert(input->schema->nodetype & (LYS_RPC | LYS_ACTION));
 
-    SR_MODINFO_INIT(mod_info, conn, SR_DS_FACTORY_DEFAULT, SR_DS_FACTORY_DEFAULT);
+    SR_MODINFO_INIT(mod_info, conn, SR_DS_FACTORY_DEFAULT, SR_DS_FACTORY_DEFAULT, operation_id);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(conn, SR_LOCK_READ, 0, __func__))) {
@@ -2689,8 +2699,8 @@ cleanup:
 
 sr_error_info_t *
 sr_shmsub_rpc_notify(sr_conn_ctx_t *conn, off_t *subs, uint32_t *sub_count, const char *path,
-        const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t timeout_ms,
-        uint32_t *request_id, struct lyd_node **output, sr_error_info_t **cb_err_info)
+        const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        uint32_t timeout_ms, uint32_t *request_id, struct lyd_node **output, sr_error_info_t **cb_err_info)
 {
     sr_error_info_t *err_info = NULL;
     char *input_lyb = NULL;
@@ -2725,7 +2735,7 @@ first_sub:
         assert(subscriber_count == 1);
 
         /* internal RPC subscription */
-        if ((err_info = sr_shmsub_rpc_internal_call_callback(conn, input, output))) {
+        if ((err_info = sr_shmsub_rpc_internal_call_callback(conn, input, operation_id, output))) {
             goto cleanup;
         }
         free(evpipes);
@@ -2763,7 +2773,7 @@ first_sub:
             assert(subscriber_count == 1);
 
             /* internal RPC subscription */
-            if ((err_info = sr_shmsub_rpc_internal_call_callback(conn, input, output))) {
+            if ((err_info = sr_shmsub_rpc_internal_call_callback(conn, input, operation_id, output))) {
                 goto cleanup;
             }
             goto next_sub;
@@ -2774,7 +2784,7 @@ first_sub:
             *request_id = ++sub_shm->request_id;
         }
         if ((err_info = sr_shmsub_notify_write_event(sub_shm, conn->cid, *request_id, cur_priority, SR_SUB_EV_RPC,
-                orig_name, orig_data, subscriber_count, &shm_data_sub, NULL, input_lyb, input_lyb_len, path))) {
+                orig_name, orig_data, subscriber_count, operation_id, &shm_data_sub, NULL, input_lyb, input_lyb_len, path))) {
             goto cleanup_wrunlock;
         }
 
@@ -2786,8 +2796,8 @@ first_sub:
         }
 
         /* wait until the event is processed */
-        if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_ERROR, 0, conn->cid, &shm_data_sub, timeout_ms,
-                &lock_lost, cb_err_info))) {
+        if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_ERROR, 0, conn->cid, operation_id, &shm_data_sub,
+                timeout_ms, &lock_lost, cb_err_info))) {
             if (lock_lost) {
                 goto cleanup;
             } else {
@@ -2798,11 +2808,11 @@ first_sub:
         if (*cb_err_info) {
             /* failed callback or timeout */
             SR_LOG_WRN("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " failed (%s).", path,
-                    sr_ev2str(SR_SUB_EV_RPC), *request_id, cur_priority, sr_strerror((*cb_err_info)->err[0].err_code));
+                    sr_ev2str(SR_SUB_EV_RPC), operation_id, cur_priority, sr_strerror((*cb_err_info)->err[0].err_code));
             goto cleanup_wrunlock;
         } else {
             SR_LOG_DBG("EV ORIGIN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " succeeded.", path,
-                    sr_ev2str(SR_SUB_EV_RPC), *request_id, cur_priority);
+                    sr_ev2str(SR_SUB_EV_RPC), operation_id, cur_priority);
         }
 
         assert(sub_shm->event == SR_SUB_EV_SUCCESS);
@@ -2850,7 +2860,7 @@ cleanup:
 
 sr_error_info_t *
 sr_shmsub_rpc_notify_abort(sr_conn_ctx_t *conn, off_t *subs, uint32_t *sub_count, const char *path,
-        const struct lyd_node *input, const char *orig_name, const void *orig_data,
+        const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t operation_id,
         uint32_t timeout_ms, uint32_t request_id)
 {
     sr_error_info_t *err_info = NULL, *cb_err_info = NULL;
@@ -2884,7 +2894,7 @@ clear_shm:
         /* clear the SHM */
         assert(sub_shm->event == SR_SUB_EV_ERROR);
         if ((err_info = sr_shmsub_notify_write_event(sub_shm, 0, request_id, cur_priority, 0, NULL, NULL, 0,
-                &shm_data_sub, NULL, NULL, 0, NULL))) {
+                operation_id, &shm_data_sub, NULL, NULL, 0, NULL))) {
             goto cleanup_wrunlock;
         }
 
@@ -2928,7 +2938,7 @@ clear_shm:
 
         /* write "abort" event with the same input */
         if ((err_info = sr_shmsub_notify_write_event(sub_shm, conn->cid, request_id, cur_priority, SR_SUB_EV_ABORT,
-                orig_name, orig_data, subscriber_count, &shm_data_sub, NULL, input_lyb, input_lyb_len, path))) {
+                orig_name, orig_data, operation_id, subscriber_count, &shm_data_sub, NULL, input_lyb, input_lyb_len, path))) {
             goto cleanup_wrunlock;
         }
 
@@ -2940,8 +2950,8 @@ clear_shm:
         }
 
         /* wait until the event is processed */
-        if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_FINISHED, 1, conn->cid, &shm_data_sub, timeout_ms,
-                &lock_lost, &cb_err_info))) {
+        if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_FINISHED, 1, conn->cid, operation_id, &shm_data_sub,
+                timeout_ms, &lock_lost, &cb_err_info))) {
             if (lock_lost) {
                 goto cleanup;
             } else {
@@ -2980,7 +2990,8 @@ cleanup:
 
 sr_error_info_t *
 sr_shmsub_notif_notify(sr_conn_ctx_t *conn, const struct lyd_node *notif, struct timespec notif_ts_mono,
-        struct timespec notif_ts_real, const char *orig_name, const void *orig_data, uint32_t timeout_ms, int wait)
+        struct timespec notif_ts_real, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        uint32_t timeout_ms, int wait)
 {
     sr_error_info_t *err_info = NULL, *cb_err_info = NULL;
     const struct lys_module *ly_mod;
@@ -3062,7 +3073,7 @@ sr_shmsub_notif_notify(sr_conn_ctx_t *conn, const struct lyd_node *notif, struct
     /* write the notification, use first subscriber CID if not waiting - depends on the subscriber, not originator */
     request_id = sub_shm->request_id + 1;
     if ((err_info = sr_shmsub_notify_write_event(sub_shm, wait ? conn->cid : sub_cid, request_id, 0, SR_SUB_EV_NOTIF,
-            orig_name, orig_data, notif_sub_count, &shm_data_sub, NULL, data, data_len, ly_mod->name))) {
+            orig_name, orig_data, notif_sub_count, operation_id, &shm_data_sub, NULL, data, data_len, ly_mod->name))) {
         goto cleanup_ext_sub_unlock;
     }
 
@@ -3088,8 +3099,8 @@ sr_shmsub_notif_notify(sr_conn_ctx_t *conn, const struct lyd_node *notif, struct
 
     if (wait) {
         /* wait until the event is processed */
-        if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_NONE, 1, conn->cid, &shm_data_sub, timeout_ms,
-                &lock_lost, &cb_err_info))) {
+        if ((err_info = sr_shmsub_notify_wait_wr(sub_shm, SR_SUB_EV_NONE, 1, conn->cid, operation_id, &shm_data_sub,
+                timeout_ms, &lock_lost, &cb_err_info))) {
             if (lock_lost) {
                 goto cleanup;
             } else {
@@ -3236,8 +3247,8 @@ sr_shmsub_listen_write_event(sr_sub_shm_t *sub_shm, uint32_t valid_subscr_count,
     }
 
     SR_LOG_DBG("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " %s (remaining %" PRIu32 " subscribers).",
-            event_desc, sr_ev2str(event), (uint32_t)ATOMIC_LOAD_RELAXED(sub_shm->request_id),
-            (uint32_t)ATOMIC_LOAD_RELAXED(sub_shm->priority), result_str, sub_shm->subscriber_count);
+            event_desc, sr_ev2str(event), sub_shm->operation_id, (uint32_t)ATOMIC_LOAD_RELAXED(sub_shm->priority),
+            result_str, sub_shm->subscriber_count);
     return NULL;
 }
 
@@ -3337,6 +3348,7 @@ struct info_sub_s {
     sr_sub_event_t event;
     uint32_t request_id;
     uint32_t priority;
+    uint32_t operation_id;
 };
 
 /**
@@ -3379,7 +3391,7 @@ sr_shmsub_change_listen_relock(sr_sub_shm_t *sub_shm, sr_lock_mode_t mode, struc
         sr_rwunlock(&sub_shm->lock, SR_SUBSHM_LOCK_TIMEOUT, mode, ev_sess->conn->cid, __func__);
 
         SR_LOG_INF("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing %s (after timeout or earlier error).",
-                module_name, sr_ev2str(sub_info->event), sub_info->request_id, sub_info->priority, err_code ? "fail" : "success");
+                module_name, sr_ev2str(sub_info->event), sub_info->operation_id, sub_info->priority, err_code ? "fail" : "success");
 
         /* self-generate abort event in case the change was applied successfully */
         if ((sub_info->event == SR_SUB_EV_CHANGE) && (err_code == SR_ERR_OK) && filter_valid &&
@@ -3394,7 +3406,7 @@ sr_shmsub_change_listen_relock(sr_sub_shm_t *sub_shm, sr_lock_mode_t mode, struc
             ev_sess->dt[ev_sess->ds].diff = abort_diff;
 
             SR_LOG_INF("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing (self-generated).",
-                    module_name, sr_ev2str(SR_SUB_EV_ABORT), sub_info->request_id, sub_info->priority);
+                    module_name, sr_ev2str(SR_SUB_EV_ABORT), sub_info->operation_id, sub_info->priority);
 
             /* call callback */
             sub->cb(ev_sess, sub->sub_id, module_name, sub->xpath, sr_ev2api(SR_SUB_EV_ABORT), sub_info->request_id,
@@ -3465,6 +3477,7 @@ sr_shmsub_change_listen_process_module_events(struct modsub_change_s *change_sub
     sub_info.event = ATOMIC_LOAD_RELAXED(sub_shm->event);
     sub_info.request_id = ATOMIC_LOAD_RELAXED(sub_shm->request_id);
     sub_info.priority = ATOMIC_LOAD_RELAXED(sub_shm->priority);
+    sub_info.operation_id = sub_shm->operation_id;
 
     /* parse originator name and data (while creating the event session) */
     if ((err_info = _sr_session_start(conn, change_subs->ds, sub_info.event, &shm_data_ptr, &ev_sess))) {
@@ -3483,7 +3496,7 @@ sr_shmsub_change_listen_process_module_events(struct modsub_change_s *change_sub
 
     /* process event */
     SR_LOG_DBG("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing (remaining %" PRIu32 " subscribers).",
-            change_subs->module_name, sr_ev2str(sub_info.event), sub_info.request_id, sub_info.priority,
+            change_subs->module_name, sr_ev2str(sub_info.event), sub_info.operation_id, sub_info.priority,
             sub_shm->subscriber_count);
 
     /* process individual subscriptions (starting at the last found subscription, it was valid) */
@@ -3506,7 +3519,7 @@ process_event:
         filter_valid = sr_shmsub_change_filter_is_valid(change_sub->xpath, diff);
         if (filter_valid) {
             ret = change_sub->cb(ev_sess, change_sub->sub_id, change_subs->module_name, change_sub->xpath,
-                    sr_ev2api(sub_info.event), sub_info.request_id, change_sub->private_data);
+                    sr_ev2api(sub_info.event), sub_info.operation_id, change_sub->private_data);
         } else if (!(change_sub->opts & SR_SUBSCR_FILTER_ORIG)) {
             /* filtered out (not by originator) */
             ATOMIC_INC_RELAXED(change_sub->filtered_out);
@@ -3528,7 +3541,7 @@ process_event:
             if (ret == SR_ERR_CALLBACK_SHELVE) {
                 /* this subscription did not process the event yet, skip it */
                 SR_LOG_INF("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing shelved.",
-                        change_subs->module_name, sr_ev2str(sub_info.event), sub_info.request_id, sub_info.priority);
+                        change_subs->module_name, sr_ev2str(sub_info.event), sub_info.operation_id, sub_info.priority);
                 continue;
             } else if (ret) {
                 /* whole event failed */
@@ -3622,6 +3635,7 @@ cleanup:
  * @param[in] mode SHM lock mode.
  * @param[in] cid Connection ID.
  * @param[in] exp_req_id Expected event request ID in the SHM.
+ * @param[in] operation_id Operation ID.
  * @param[in] err_code Error code of the callback.
  * @param[out] err_info Optional error info on error.
  * @return 0 if SHM content is as expected.
@@ -3630,7 +3644,7 @@ cleanup:
  */
 static int
 sr_shmsub_oper_get_listen_relock(sr_sub_shm_t *sub_shm, sr_lock_mode_t mode, sr_cid_t cid, uint32_t exp_req_id,
-        sr_error_t err_code, sr_error_info_t **err_info)
+        uint32_t operation_id, sr_error_t err_code, sr_error_info_t **err_info)
 {
     assert(!*err_info);
 
@@ -3645,7 +3659,7 @@ sr_shmsub_oper_get_listen_relock(sr_sub_shm_t *sub_shm, sr_lock_mode_t mode, sr_
         sr_rwunlock(&sub_shm->lock, SR_SUBSHM_LOCK_TIMEOUT, mode, cid, __func__);
 
         SR_LOG_INF("EV LISTEN: \"%s\" ID %" PRIu32 " processing %s (after timeout).", sr_ev2str(SR_SUB_EV_OPER),
-                exp_req_id, err_code ? "fail" : "success");
+                operation_id, err_code ? "fail" : "success");
 
         /* we have completely finished processing (with no error) */
         return 1;
@@ -3659,7 +3673,7 @@ sr_error_info_t *
 sr_shmsub_oper_get_listen_process_module_events(struct modsub_operget_s *oper_get_subs, sr_conn_ctx_t *conn)
 {
     sr_error_info_t *err_info = NULL;
-    uint32_t i, data_len = 0, request_id;
+    uint32_t i, data_len = 0, request_id, operation_id;
     char *data = NULL, *request_xpath = NULL, *shm_data_ptr;
     const char *origin;
     sr_error_t err_code = SR_ERR_OK;
@@ -3698,6 +3712,7 @@ sr_shmsub_oper_get_listen_process_module_events(struct modsub_operget_s *oper_ge
             continue;
         }
         request_id = ATOMIC_LOAD_RELAXED(sub_shm->request_id);
+        operation_id = sub_shm->operation_id;
 
         /* open sub data SHM */
         if ((err_info = sr_shmsub_data_open_remap(oper_get_subs->module_name, "oper", sr_str_hash(oper_get_sub->path,
@@ -3732,12 +3747,12 @@ sr_shmsub_oper_get_listen_process_module_events(struct modsub_operget_s *oper_ge
 
         /* process event */
         SR_LOG_DBG("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " processing.", oper_get_sub->path, sr_ev2str(SR_SUB_EV_OPER),
-                request_id);
+                operation_id);
 
         /* call callback */
         orig_parent = parent;
         err_code = oper_get_sub->cb(ev_sess, oper_get_sub->sub_id, oper_get_subs->module_name, oper_get_sub->path,
-                request_xpath[0] ? request_xpath : NULL, request_id, &parent, oper_get_sub->private_data);
+                request_xpath[0] ? request_xpath : NULL, operation_id, &parent, oper_get_sub->private_data);
 
         /* go again to the top-level root for printing */
         if (parent) {
@@ -3758,7 +3773,7 @@ sr_shmsub_oper_get_listen_process_module_events(struct modsub_operget_s *oper_ge
         if (err_code == SR_ERR_CALLBACK_SHELVE) {
             /* this subscription did not process the event yet, skip it */
             SR_LOG_INF("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " processing shelved.", oper_get_sub->path,
-                    sr_ev2str(SR_SUB_EV_OPER), request_id);
+                    sr_ev2str(SR_SUB_EV_OPER), operation_id);
             goto next_iter;
         }
 
@@ -3779,7 +3794,8 @@ sr_shmsub_oper_get_listen_process_module_events(struct modsub_operget_s *oper_ge
         }
 
         /* SUB WRITE LOCK */
-        if (sr_shmsub_oper_get_listen_relock(sub_shm, SR_LOCK_WRITE, conn->cid, request_id, err_code, &err_info)) {
+        if (sr_shmsub_oper_get_listen_relock(sub_shm, SR_LOCK_WRITE, conn->cid, request_id, operation_id, err_code,
+                &err_info)) {
             /* not necessarily an error */
             goto error;
         }
@@ -3806,7 +3822,6 @@ next_iter:
         sr_shm_clear(&shm_data_sub);
     }
 
-    /* success */
     return NULL;
 
 error_wrunlock:
@@ -3944,7 +3959,7 @@ sr_shmsub_oper_poll_listen_process_module_events(struct modsub_operpoll_s *oper_
     SR_CHECK_INT_GOTO(!ly_mod, err_info, cleanup);
 
     /* init mod info */
-    SR_MODINFO_INIT(mod_info, conn, SR_DS_OPERATIONAL, SR_DS_OPERATIONAL);
+    SR_MODINFO_INIT(mod_info, conn, SR_DS_OPERATIONAL, SR_DS_OPERATIONAL, 0);
     if ((err_info = sr_modinfo_add(ly_mod, NULL, 0, 0, &mod_info))) {
         goto cleanup;
     }
@@ -4174,14 +4189,14 @@ cleanup:
  * @param[in] ev_sess Temporary event callback session.
  * @param[in] input_op Input tree pointing to the operation node.
  * @param[in] event Subscription event.
- * @param[in] request_id Request ID.
+ * @param[in] operation_id Operation ID.
  * @param[out] output_op Output tree pointing to the operation node.
  * @param[out] err_code Returned error code if the callback failed.
  * @return err_info, NULL on success.
  */
 static sr_error_info_t *
 sr_shmsub_rpc_listen_call_callback(struct opsub_rpcsub_s *rpc_sub, sr_session_ctx_t *ev_sess, const struct lyd_node *input_op,
-        sr_sub_event_t event, uint32_t request_id, struct lyd_node **output_op, sr_error_t *err_code)
+        sr_sub_event_t event, uint32_t operation_id, struct lyd_node **output_op, sr_error_t *err_code)
 {
     sr_error_info_t *err_info = NULL;
     const struct lyd_node *elem;
@@ -4203,7 +4218,7 @@ sr_shmsub_rpc_listen_call_callback(struct opsub_rpcsub_s *rpc_sub, sr_session_ct
         }
 
         /* callback */
-        *err_code = rpc_sub->tree_cb(ev_sess, rpc_sub->sub_id, rpc_sub->xpath, input_op, sr_ev2api(event), request_id,
+        *err_code = rpc_sub->tree_cb(ev_sess, rpc_sub->sub_id, rpc_sub->xpath, input_op, sr_ev2api(event), operation_id,
                 *output_op, rpc_sub->private_data);
         if (*err_code) {
             goto cleanup;
@@ -4240,7 +4255,7 @@ sr_shmsub_rpc_listen_call_callback(struct opsub_rpcsub_s *rpc_sub, sr_session_ct
         output_vals = NULL;
         output_val_count = 0;
         *err_code = rpc_sub->cb(ev_sess, rpc_sub->sub_id, op_xpath, input_vals, input_val_count, sr_ev2api(event),
-                request_id, &output_vals, &output_val_count, rpc_sub->private_data);
+                operation_id, &output_vals, &output_val_count, rpc_sub->private_data);
         if (*err_code) {
             goto cleanup;
         }
@@ -4376,7 +4391,7 @@ sr_shmsub_rpc_listen_relock(sr_sub_shm_t *sub_shm, sr_lock_mode_t mode, struct i
         sr_rwunlock(&sub_shm->lock, SR_SUBSHM_LOCK_TIMEOUT, mode, ev_sess->conn->cid, __func__);
 
         SR_LOG_INF("EV LISTEN: \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing %s (after timeout or earlier error).",
-                sr_ev2str(sub_info->event), sub_info->request_id, sub_info->priority, err_code ? "Failed" : "Successful");
+                sr_ev2str(sub_info->event), sub_info->operation_id, sub_info->priority, err_code ? "Failed" : "Successful");
 
         /* self-generate abort event in case the RPC was applied successfully */
         if (err_code == SR_ERR_OK) {
@@ -4384,11 +4399,11 @@ sr_shmsub_rpc_listen_relock(sr_sub_shm_t *sub_shm, sr_lock_mode_t mode, struct i
             ev_sess->ev = SR_SUB_EV_ABORT;
 
             SR_LOG_INF("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing (self-generated).",
-                    path, sr_ev2str(SR_SUB_EV_ABORT), sub_info->request_id, sub_info->priority);
+                    path, sr_ev2str(SR_SUB_EV_ABORT), sub_info->operation_id, sub_info->priority);
 
             /* call callback */
             *err_info = sr_shmsub_rpc_listen_call_callback(sub, ev_sess, input_op, SR_SUB_EV_ABORT,
-                    sub_info->request_id, &output, &err_code);
+                    sub_info->operation_id, &output, &err_code);
 
             /* we do not care about output of error code */
             lyd_free_all(output);
@@ -4477,6 +4492,7 @@ sr_shmsub_rpc_listen_process_rpc_events(struct opsub_rpc_s *rpc_subs, sr_conn_ct
     sub_info.event = ATOMIC_LOAD_RELAXED(sub_shm->event);
     sub_info.request_id = ATOMIC_LOAD_RELAXED(sub_shm->request_id);
     sub_info.priority = ATOMIC_LOAD_RELAXED(sub_shm->priority);
+    sub_info.operation_id = sub_shm->operation_id;
 
     /* go to the operation, not the root */
     input_op = input;
@@ -4486,7 +4502,7 @@ sr_shmsub_rpc_listen_process_rpc_events(struct opsub_rpc_s *rpc_subs, sr_conn_ct
 
     /* process event */
     SR_LOG_DBG("EV LISTEN: \"%s\" \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing (remaining %" PRIu32 " subscribers).",
-            rpc_subs->path, sr_ev2str(sub_info.event), sub_info.request_id, sub_info.priority,
+            rpc_subs->path, sr_ev2str(sub_info.event), sub_info.operation_id, sub_info.priority,
             sub_shm->subscriber_count);
 
     /* process individual subscriptions (starting at the last found subscription, it was valid) */
@@ -4510,7 +4526,7 @@ process_event:
 
         /* call callback */
         if ((err_info = sr_shmsub_rpc_listen_call_callback(rpc_sub, ev_sess, input_op, sub_info.event,
-                sub_info.request_id, &output, &ret))) {
+                sub_info.operation_id, &output, &ret))) {
             goto cleanup;
         }
 
@@ -4525,8 +4541,7 @@ process_event:
             if (ret == SR_ERR_CALLBACK_SHELVE) {
                 /* processing was shelved, so interupt the whole RPC processing in order to get correct final output */
                 SR_LOG_INF("EV LISTEN: \"%s\" ID %" PRIu32 " priority %" PRIu32 " processing shelved.",
-                        sr_ev2str(ATOMIC_LOAD_RELAXED(sub_shm->event)),
-                        (uint32_t)ATOMIC_LOAD_RELAXED(sub_shm->request_id),
+                        sr_ev2str(ATOMIC_LOAD_RELAXED(sub_shm->event)), sub_shm->operation_id,
                         (uint32_t)ATOMIC_LOAD_RELAXED(sub_shm->priority));
                 goto cleanup;
             } else if (ret != SR_ERR_OK) {
@@ -4626,7 +4641,7 @@ sr_error_info_t *
 sr_shmsub_notif_listen_process_module_events(struct modsub_notif_s *notif_subs, sr_conn_ctx_t *conn)
 {
     sr_error_info_t *err_info = NULL;
-    uint32_t i, request_id, valid_subscr_count;
+    uint32_t i, request_id, operation_id, valid_subscr_count;
     struct lyd_node *notif = NULL, *notif_op;
     struct sr_denied denied = {0};
     struct timespec notif_ts_mono, notif_ts_real;
@@ -4656,6 +4671,7 @@ sr_shmsub_notif_listen_process_module_events(struct modsub_notif_s *notif_subs,
         goto cleanup_rdunlock;
     }
     request_id = ATOMIC_LOAD_RELAXED(sub_shm->request_id);
+    operation_id = sub_shm->operation_id;
 
     /* open sub data SHM */
     if ((err_info = sr_shmsub_data_open_remap(notif_subs->module_name, "notif", -1, &shm_data_sub, 0))) {
@@ -4695,13 +4711,13 @@ sr_shmsub_notif_listen_process_module_events(struct modsub_notif_s *notif_subs,
 
         if (!valid_subscr_count) {
             /* Print a message only the first time we get here */
-            SR_LOG_DBG("EV LISTEN: \"%s\" \"notif\" ID %" PRIu32 " processing.", notif_subs->module_name, request_id);
+            SR_LOG_DBG("EV LISTEN: \"%s\" \"notif\" ID %" PRIu32 " processing.", notif_subs->module_name, operation_id);
         }
 
         if (sr_time_cmp(&sub->listen_since_mono, &notif_ts_mono) > 0) {
             /* generated before this subscription has been made */
             SR_LOG_DBG("EV LISTEN: \"%s\" \"notif\" ID %" PRIu32 " ignored, subscription created after the notification.",
-                    notif_subs->module_name, request_id);
+                    notif_subs->module_name, operation_id);
             continue;
         }
 
@@ -4747,7 +4763,7 @@ sr_shmsub_notif_listen_process_module_events(struct modsub_notif_s *notif_subs,
     if ((ATOMIC_LOAD_RELAXED(sub_shm->event) != SR_SUB_EV_NOTIF) ||
             (ATOMIC_LOAD_RELAXED(sub_shm->request_id) != ATOMIC_LOAD_RELAXED(notif_subs->request_id))) {
         SR_LOG_INF("EV LISTEN: \"%s\" ID %" PRIu32 " processing success (after timeout).", sr_ev2str(SR_SUB_EV_NOTIF),
-                (uint32_t)ATOMIC_LOAD_RELAXED(notif_subs->request_id));
+                operation_id);
         goto cleanup_wrunlock;
     }
 
diff --git a/src/shm_sub.h b/src/shm_sub.h
index 62050e98..505dab39 100644
--- a/src/shm_sub.h
+++ b/src/shm_sub.h
@@ -167,6 +167,7 @@ sr_error_info_t *sr_shmsub_change_notify_change_abort(struct sr_mod_info_s *mod_
  * @param[in] parent Existing parent to append the data to.
  * @param[in] orig_name Event originator name.
  * @param[in] orig_data Event originator data.
+ * @param[in] operation_id Operation ID.
  * @param[in] oper_get_subs An array of operational get subscriptions.
  * @param[in] idx1 Index of the array where operational subscriptions with the same XPath are.
  * @param[in] timeout_ms Operational callback timeout in milliseconds.
@@ -176,8 +177,9 @@ sr_error_info_t *sr_shmsub_change_notify_change_abort(struct sr_mod_info_s *mod_
  * @return err_info, NULL on success.
  */
 sr_error_info_t *sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const char *xpath, const char *request_xpath,
-        const struct lyd_node *parent, const char *orig_name, const void *orig_data, sr_mod_oper_get_sub_t *oper_get_subs,
-        uint32_t idx1, uint32_t timeout_ms, sr_conn_ctx_t *conn, struct lyd_node **data, sr_error_info_t **cb_err_info);
+        const struct lyd_node *parent, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        sr_mod_oper_get_sub_t *oper_get_subs, uint32_t idx1, uint32_t timeout_ms, sr_conn_ctx_t *conn,
+        struct lyd_node **data, sr_error_info_t **cb_err_info);
 
 /**
  * @brief Notify about (generate) an RPC/action event.
@@ -191,6 +193,7 @@ sr_error_info_t *sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const
  * @param[in] input Operation input tree.
  * @param[in] orig_name Event originator name.
  * @param[in] orig_data Event originator data.
+ * @param[in] operation_id Operation ID.
  * @param[in] timeout_ms RPC/action callback timeout in milliseconds.
  * @param[in,out] request_id Generated request ID, set to 0 when passing.
  * @param[out] output Operation output returned by the last subscriber on success.
@@ -198,8 +201,8 @@ sr_error_info_t *sr_shmsub_oper_get_notify(struct sr_mod_info_mod_s *mod, const
  * @return err_info, NULL on success.
  */
 sr_error_info_t *sr_shmsub_rpc_notify(sr_conn_ctx_t *conn, off_t *subs, uint32_t *sub_count, const char *path,
-        const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t timeout_ms,
-        uint32_t *request_id, struct lyd_node **output, sr_error_info_t **cb_err_info);
+        const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        uint32_t timeout_ms, uint32_t *request_id, struct lyd_node **output, sr_error_info_t **cb_err_info);
 
 /**
  * @brief Notify about (generate) an RPC/action abort event.
@@ -211,13 +214,14 @@ sr_error_info_t *sr_shmsub_rpc_notify(sr_conn_ctx_t *conn, off_t *subs, uint32_t
  * @param[in] input Operation input tree.
  * @param[in] orig_name Event originator name.
  * @param[in] orig_data Event originator data.
+ * @param[in] operation_id Operation ID.
  * @param[in] timeout_ms RPC/action callback timeout in milliseconds.
  * @param[in] request_id Generated request ID from previous event.
  * @return err_info, NULL on success.
  */
-sr_error_info_t *sr_shmsub_rpc_notify_abort(sr_conn_ctx_t *conn, off_t *subs, uint32_t *sub_count,
-        const char *path, const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t timeout_ms,
-        uint32_t request_id);
+sr_error_info_t *sr_shmsub_rpc_notify_abort(sr_conn_ctx_t *conn, off_t *subs, uint32_t *sub_count, const char *path,
+        const struct lyd_node *input, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        uint32_t timeout_ms, uint32_t request_id);
 
 /**
  * @brief Notify about (generate) a notification event.
@@ -228,12 +232,14 @@ sr_error_info_t *sr_shmsub_rpc_notify_abort(sr_conn_ctx_t *conn, off_t *subs, ui
  * @param[in] notif_ts_real Notification realtime timestamp.
  * @param[in] orig_name Event originator name.
  * @param[in] orig_data Event originator data.
+ * @param[in] operation_id Operation ID.
  * @param[in] timeout_ms Notification callback timeout in milliseconds. Used only if @p wait is set.
  * @param[in] wait Whether to wait for the callbacks or not.
  * @return err_info, NULL on success.
  */
 sr_error_info_t *sr_shmsub_notif_notify(sr_conn_ctx_t *conn, const struct lyd_node *notif, struct timespec notif_ts_mono,
-        struct timespec notif_ts_real, const char *orig_name, const void *orig_data, uint32_t timeout_ms, int wait);
+        struct timespec notif_ts_real, const char *orig_name, const void *orig_data, uint32_t operation_id,
+        uint32_t timeout_ms, int wait);
 
 /**
  * @brief Write the result of having processed an event.
@@ -250,9 +256,8 @@ sr_error_info_t *sr_shmsub_notif_notify(sr_conn_ctx_t *conn, const struct lyd_no
  * @param[in] result_str Result of processing the event in string.
  * @return err_info, NULL on success.
  */
-sr_error_info_t *sr_shmsub_listen_write_event(sr_sub_shm_t *sub_shm, uint32_t valid_subscr_count,
-        sr_error_t err_code, sr_shm_t *shm_data_sub, const char *data, uint32_t data_len, const char *event_desc,
-        const char *result_str);
+sr_error_info_t *sr_shmsub_listen_write_event(sr_sub_shm_t *sub_shm, uint32_t valid_subscr_count, sr_error_t err_code,
+        sr_shm_t *shm_data_sub, const char *data, uint32_t data_len, const char *event_desc, const char *result_str);
 
 /**
  * @brief Process all module change events, if any.
diff --git a/src/shm_types.h b/src/shm_types.h
index 7b43ecef..5e5f4e77 100644
--- a/src/shm_types.h
+++ b/src/shm_types.h
@@ -25,7 +25,7 @@
 #include "common_types.h"
 #include "sysrepo_types.h"
 
-#define SR_SHM_VER 18   /**< Main, mod, and ext SHM version of their expected content structures. */
+#define SR_SHM_VER 19   /**< Main, mod, and ext SHM version of their expected content structures. */
 #define SR_MAIN_SHM_LOCK "sr_main_lock"     /**< Main SHM file lock name. */
 
 /**
@@ -201,6 +201,7 @@ typedef struct {
     ATOMIC_T new_sr_sid;        /**< SID for a new session. */
     ATOMIC_T new_sub_id;        /**< Subscription ID of a new subscription. */
     ATOMIC_T new_evpipe_num;    /**< Event pipe number for a new subscription. */
+    ATOMIC_T new_operation_id;  /**< Operation ID to use for each callback of every operation. */
 
     char repo_path[256];        /**< Repository path used when main SHM was created. */
 } sr_main_shm_t;
@@ -367,6 +368,7 @@ typedef struct {
 
     ATOMIC_T priority;          /**< Priority of the subscriber. */
     uint32_t subscriber_count;  /**< Number of subscribers to process this event. */
+    uint32_t operation_id;      /**< Operation ID for the callback. */
 } sr_sub_shm_t;
 
 #endif /* _SHM_TYPES_H */
diff --git a/src/sysrepo.c b/src/sysrepo.c
index 797de6aa..97537207 100644
--- a/src/sysrepo.c
+++ b/src/sysrepo.c
@@ -2778,7 +2778,7 @@ sr_get_item(sr_session_ctx_t *session, const char *path, uint32_t timeout_ms, sr
     }
     *value = NULL;
     /* for operational, use operational and running datastore */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -2882,7 +2882,7 @@ sr_get_items(sr_session_ctx_t *session, const char *xpath, uint32_t timeout_ms,
     *values = NULL;
     *value_cnt = 0;
     /* for operational, use operational and running datastore */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -3041,7 +3041,7 @@ sr_get_subtree(sr_session_ctx_t *session, const char *path, uint32_t timeout_ms,
         timeout_ms = SR_OPER_CB_TIMEOUT;
     }
     /* for operational, use operational and running datastore */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -3156,7 +3156,7 @@ sr_get_data(sr_session_ctx_t *session, const char *xpath, uint32_t max_depth, ui
     }
 
     /* for operational, use operational and running datastore */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -3293,7 +3293,7 @@ sr_get_node(sr_session_ctx_t *session, const char *path, uint32_t timeout_ms, sr
     }
 
     /* for operational, use operational and running datastore */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -3866,7 +3866,7 @@ sr_validate(sr_session_ctx_t *session, const char *module_name, uint32_t timeout
         timeout_ms = SR_OPER_CB_TIMEOUT;
     }
     /* for operational, use operational and running datastore */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -4281,7 +4281,7 @@ sr_apply_changes(sr_session_ctx_t *session, uint32_t timeout_ms)
     }
 
     /* prepare mod_info */
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds, 0);
 
     if (session->ds == SR_DS_OPERATIONAL) {
         /* handle specially */
@@ -4419,20 +4419,21 @@ cleanup:
  *
  * @param[in] session Session to use.
  * @param[in] ly_mod Optional specific module.
+ * @param[in] operation_id Operation ID.
  * @param[in,out] src_config Source data for the replace, they are spent.
  * @param[in] timeout_ms Change callback timeout in milliseconds.
  * @return err_info, NULL on success.
  */
 static sr_error_info_t *
-_sr_replace_config(sr_session_ctx_t *session, const struct lys_module *ly_mod, struct lyd_node **src_config,
-        uint32_t timeout_ms)
+_sr_replace_config(sr_session_ctx_t *session, const struct lys_module *ly_mod, uint32_t operation_id,
+        struct lyd_node **src_config, uint32_t timeout_ms)
 {
     sr_error_info_t *err_info = NULL, *cb_err_info = NULL;
     struct sr_mod_info_s mod_info;
 
     assert(!*src_config || !(*src_config)->prev->next);
     assert(session->ds != SR_DS_OPERATIONAL);
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds, operation_id);
 
     /* single module/all modules */
     if (ly_mod) {
@@ -4514,7 +4515,7 @@ sr_replace_config(sr_session_ctx_t *session, const char *module_name, struct lyd
     }
 
     /* replace the data */
-    if ((err_info = _sr_replace_config(session, ly_mod, &src_config, timeout_ms))) {
+    if ((err_info = _sr_replace_config(session, ly_mod, 0, &src_config, timeout_ms))) {
         goto cleanup_unlock;
     }
 
@@ -4547,9 +4548,9 @@ sr_copy_config(sr_session_ctx_t *session, const char *module_name, sr_datastore_
     }
     if ((src_datastore == SR_DS_RUNNING) && (session->ds == SR_DS_CANDIDATE)) {
         /* discard-changes, need no data, but lock running for READ and candidate for WRITE */
-        SR_MODINFO_INIT(mod_info, session->conn, session->ds, src_datastore);
+        SR_MODINFO_INIT(mod_info, session->conn, session->ds, src_datastore, 0);
     } else {
-        SR_MODINFO_INIT(mod_info, session->conn, src_datastore, src_datastore);
+        SR_MODINFO_INIT(mod_info, session->conn, src_datastore, src_datastore, 0);
     }
 
     /* CONTEXT LOCK */
@@ -4598,7 +4599,7 @@ sr_copy_config(sr_session_ctx_t *session, const char *module_name, sr_datastore_
         }
 
         /* replace the data */
-        if ((err_info = _sr_replace_config(session, ly_mod, &mod_info.data, timeout_ms))) {
+        if ((err_info = _sr_replace_config(session, ly_mod, mod_info.operation_id, &mod_info.data, timeout_ms))) {
             goto cleanup;
         }
 
@@ -4616,7 +4617,7 @@ sr_copy_config(sr_session_ctx_t *session, const char *module_name, sr_datastore_
         sr_shmmod_modinfo_unlock(&mod_info);
 
         /* replace the data */
-        if ((err_info = _sr_replace_config(session, ly_mod, &mod_info.data, timeout_ms))) {
+        if ((err_info = _sr_replace_config(session, ly_mod, mod_info.operation_id, &mod_info.data, timeout_ms))) {
             goto cleanup;
         }
     }
@@ -4655,7 +4656,7 @@ _sr_discard_oper_changes(sr_session_ctx_t *session, const char *module_name, int
     if (!timeout_ms) {
         timeout_ms = SR_CHANGE_CB_TIMEOUT;
     }
-    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_OPERATIONAL);
+    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_OPERATIONAL, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -4720,7 +4721,7 @@ sr_get_oper_changes(sr_session_ctx_t *session, const char *module_name, sr_data_
         return sr_api_ret(session, err_info);
     }
 
-    SR_MODINFO_INIT(mod_info, conn, SR_DS_OPERATIONAL, SR_DS_OPERATIONAL);
+    SR_MODINFO_INIT(mod_info, conn, SR_DS_OPERATIONAL, SR_DS_OPERATIONAL, 0);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(conn, SR_LOCK_READ, 0, __func__))) {
@@ -4937,7 +4938,7 @@ _sr_un_lock(sr_session_ctx_t *session, const char *module_name, int lock, uint32
 
     SR_CHECK_ARG_APIRET(!session || !SR_IS_CONVENTIONAL_DS(session->ds), session, err_info);
 
-    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds, 1);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -5023,7 +5024,7 @@ sr_get_lock(sr_conn_ctx_t *conn, sr_datastore_t datastore, const char *module_na
     if (timestamp) {
         memset(timestamp, 0, sizeof *timestamp);
     }
-    SR_MODINFO_INIT(mod_info, conn, datastore, datastore);
+    SR_MODINFO_INIT(mod_info, conn, datastore, datastore, 1);
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(conn, SR_LOCK_READ, 0, __func__))) {
@@ -5686,8 +5687,6 @@ sr_module_change_subscribe_enable(sr_session_ctx_t *session, struct sr_mod_info_
     sr_session_ctx_t *ev_sess = NULL;
     sr_error_t err_code;
 
-    SR_MODINFO_INIT((*mod_info), session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds);
-
     /* create mod_info structure with this module only, do not use cache to allow reading data in the callback
      * (avoid dead-lock) */
     if ((err_info = sr_modinfo_add(ly_mod, NULL, 0, 0, mod_info))) {
@@ -5739,7 +5738,8 @@ sr_module_change_subscribe_enable(sr_session_ctx_t *session, struct sr_mod_info_
         SR_LOG_INF("Triggering \"%s\" \"%s\" event on enabled data.", ly_mod->name, sr_ev2str(ev_sess->ev));
 
         /* present all changes in an "enabled" event */
-        err_code = callback(ev_sess, sub_id, ly_mod->name, xpath, sr_ev2api(ev_sess->ev), 0, private_data);
+        err_code = callback(ev_sess, sub_id, ly_mod->name, xpath, sr_ev2api(ev_sess->ev), mod_info->operation_id,
+                private_data);
         if (err_code != SR_ERR_OK) {
             /* callback failed but it is the only one so no "abort" event is necessary */
             if (ev_sess->ev_err_info) {
@@ -5856,7 +5856,7 @@ sr_module_change_subscribe(sr_session_ctx_t *session, const char *module_name, c
     SR_CHECK_ARG_APIRET(!session || !SR_IS_STANDARD_DS(session->ds) || SR_IS_EVENT_SESS(session) || !module_name ||
             !callback || !subscription, session, err_info);
 
-    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_RUNNING, SR_DS_RUNNING);
+    SR_MODINFO_INIT(mod_info, session->conn, session->ds, session->ds == SR_DS_OPERATIONAL ? SR_DS_RUNNING : session->ds, 0);
 
     conn = session->conn;
     /* only these options are relevant outside this function and will be stored */
@@ -6761,7 +6761,7 @@ _sr_rpc_send_tree(sr_session_ctx_t *session, struct sr_mod_info_s *mod_info, con
     sr_rpc_t *shm_rpc;
     sr_dep_t *shm_deps;
     uint16_t shm_dep_count;
-    uint32_t event_id = 0;
+    uint32_t request_id = 0;
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -6794,7 +6794,7 @@ _sr_rpc_send_tree(sr_session_ctx_t *session, struct sr_mod_info_s *mod_info, con
     sr_shmmod_modinfo_unlock(mod_info);
 
     sr_modinfo_erase(mod_info);
-    SR_MODINFO_INIT(*mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_RUNNING);
+    SR_MODINFO_INIT(*mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_RUNNING, 0);
 
     if (!strcmp(path, SR_RPC_FACTORY_RESET_PATH)) {
         /* update the input as needed */
@@ -6815,14 +6815,15 @@ _sr_rpc_send_tree(sr_session_ctx_t *session, struct sr_mod_info_s *mod_info, con
 
     /* publish RPC in an event and wait for a reply from the last subscriber */
     if ((err_info = sr_shmsub_rpc_notify(session->conn, &shm_rpc->subs, &shm_rpc->sub_count, path, input,
-            session->orig_name, session->orig_data, timeout_ms, &event_id, &(*output)->tree, &cb_err_info))) {
+            session->orig_name, session->orig_data, mod_info->operation_id, timeout_ms, &request_id, &(*output)->tree,
+            &cb_err_info))) {
         goto cleanup_rpcsub_unlock;
     }
 
     if (cb_err_info) {
         /* "rpc" event failed, publish "abort" event and finish */
         err_info = sr_shmsub_rpc_notify_abort(session->conn, &shm_rpc->subs, &shm_rpc->sub_count, path,
-                input, session->orig_name, session->orig_data, timeout_ms, event_id);
+                input, session->orig_name, session->orig_data, mod_info->operation_id, timeout_ms, request_id);
         goto cleanup_rpcsub_unlock;
     }
 
@@ -6890,7 +6891,7 @@ _sr_rpc_ext_send_tree(sr_session_ctx_t *session, const struct lyd_node *ext_pare
 {
     sr_error_info_t *err_info = NULL, *cb_err_info = NULL;
     sr_mod_t *shm_mod;
-    uint32_t event_id = 0;
+    uint32_t request_id = 0;
 
     /* CONTEXT LOCK */
     if ((err_info = sr_lycc_lock(session->conn, SR_LOCK_READ, 0, __func__))) {
@@ -6930,16 +6931,16 @@ _sr_rpc_ext_send_tree(sr_session_ctx_t *session, const struct lyd_node *ext_pare
     }
 
     /* publish RPC in an event and wait for a reply from the last subscriber */
-    if ((err_info = sr_shmsub_rpc_notify(session->conn, &shm_mod->rpc_ext_subs,
-            &shm_mod->rpc_ext_sub_count, path, input, session->orig_name, session->orig_data, timeout_ms, &event_id,
+    if ((err_info = sr_shmsub_rpc_notify(session->conn, &shm_mod->rpc_ext_subs, &shm_mod->rpc_ext_sub_count, path,
+            input, session->orig_name, session->orig_data, mod_info->operation_id, timeout_ms, &request_id,
             &(*output)->tree, &cb_err_info))) {
         goto cleanup_rpcsub_unlock;
     }
 
     if (cb_err_info) {
         /* "rpc" event failed, publish "abort" event and finish */
-        err_info = sr_shmsub_rpc_notify_abort(session->conn, &shm_mod->rpc_ext_subs,
-                &shm_mod->rpc_ext_sub_count, path, input, session->orig_name, session->orig_data, timeout_ms, event_id);
+        err_info = sr_shmsub_rpc_notify_abort(session->conn, &shm_mod->rpc_ext_subs, &shm_mod->rpc_ext_sub_count, path,
+                input, session->orig_name, session->orig_data, mod_info->operation_id, timeout_ms, request_id);
         goto cleanup_rpcsub_unlock;
     }
 
@@ -6963,7 +6964,6 @@ _sr_rpc_ext_send_tree(sr_session_ctx_t *session, const struct lyd_node *ext_pare
         goto cleanup;
     }
 
-    /* success */
     goto cleanup;
 
 cleanup_rpcsub_unlock:
@@ -7003,7 +7003,7 @@ sr_rpc_send_tree(sr_session_ctx_t *session, struct lyd_node *input, uint32_t tim
     if (!timeout_ms) {
         timeout_ms = SR_RPC_CB_TIMEOUT;
     }
-    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_RUNNING);
+    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_RUNNING, 0);
 
     /* check input data tree */
     input_op = NULL;
@@ -7330,7 +7330,7 @@ sr_notif_send_tree(sr_session_ctx_t *session, struct lyd_node *notif, uint32_t t
     if (!timeout_ms) {
         timeout_ms = SR_NOTIF_CB_TIMEOUT;
     }
-    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_RUNNING);
+    SR_MODINFO_INIT(mod_info, session->conn, SR_DS_OPERATIONAL, SR_DS_RUNNING, 0);
 
     /* check notif data tree */
     notif_op = NULL;
@@ -7423,7 +7423,7 @@ sr_notif_send_tree(sr_session_ctx_t *session, struct lyd_node *notif, uint32_t t
 
     /* publish notif in an event */
     err_info = sr_shmsub_notif_notify(session->conn, notif_top, notif_ts_mono, notif_ts_real, session->orig_name,
-            session->orig_data, timeout_ms, wait);
+            session->orig_data, mod_info.operation_id, timeout_ms, wait);
 
     /* NOTIF SUB READ UNLOCK */
     sr_rwunlock(&shm_mod->notif_lock, SR_SHMEXT_SUB_LOCK_TIMEOUT, SR_LOCK_READ, session->conn->cid, __func__);
diff --git a/src/sysrepo_types.h b/src/sysrepo_types.h
index dff6f5bb..337ee51a 100644
--- a/src/sysrepo_types.h
+++ b/src/sysrepo_types.h
@@ -542,13 +542,12 @@ typedef struct sr_change_iter_s sr_change_iter_t;
  * @param[in] module_name Name of the module where the change has occurred.
  * @param[in] xpath [XPath](@ref paths) used when subscribing, NULL if the whole module was subscribed to.
  * @param[in] event Type of the callback event that has occurred.
- * @param[in] request_id Request ID unique for the specific @p module_name. Connected events
- * for one request (::SR_EV_CHANGE and ::SR_EV_DONE, for example) have the same request ID.
+ * @param[in] operation_id Operation ID of the current operation used for all the callbacks and events.
  * @param[in] private_data Private context opaque to sysrepo, as passed to ::sr_module_change_subscribe call.
  * @return User error code (::SR_ERR_OK on success).
  */
 typedef int (*sr_module_change_cb)(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *xpath,
-        sr_event_t event, uint32_t request_id, void *private_data);
+        sr_event_t event, uint32_t operation_id, void *private_data);
 
 /** @} datasubs */
 
@@ -568,7 +567,7 @@ typedef int (*sr_module_change_cb)(sr_session_ctx_t *session, uint32_t sub_id, c
  * @param[in] input Array of input parameters.
  * @param[in] input_cnt Number of input parameters.
  * @param[in] event Type of the callback event that has occurred.
- * @param[in] request_id Request ID unique for the specific @p op_path.
+ * @param[in] operation_id Operation ID of the current operation used for all the callbacks and events.
  * @param[out] output Array of output parameters. Should be allocated on heap,
  * will be freed by sysrepo after sending of the RPC response.
  * @param[out] output_cnt Number of output parameters.
@@ -576,7 +575,7 @@ typedef int (*sr_module_change_cb)(sr_session_ctx_t *session, uint32_t sub_id, c
  * @return User error code (::SR_ERR_OK on success).
  */
 typedef int (*sr_rpc_cb)(sr_session_ctx_t *session, uint32_t sub_id, const char *xpath, const sr_val_t *input,
-        const size_t input_cnt, sr_event_t event, uint32_t request_id, sr_val_t **output, size_t *output_cnt,
+        const size_t input_cnt, sr_event_t event, uint32_t operation_id, sr_val_t **output, size_t *output_cnt,
         void *private_data);
 
 /**
@@ -589,13 +588,13 @@ typedef int (*sr_rpc_cb)(sr_session_ctx_t *session, uint32_t sub_id, const char
  * @param[in] op_path Simple operation [path](@ref paths) identifying the RPC/action.
  * @param[in] input Data tree of input parameters. Always points to the __RPC/action__ itself, even for nested operations.
  * @param[in] event Type of the callback event that has occurred.
- * @param[in] request_id Request ID unique for the specific @p op_path.
+ * @param[in] operation_id Operation ID of the current operation used for all the callbacks and events.
  * @param[out] output Data tree for appending any output parameters, the operation root node is provided..
  * @param[in] private_data Private context opaque to sysrepo, as passed to ::sr_rpc_subscribe_tree call.
  * @return User error code (::SR_ERR_OK on success).
  */
 typedef int (*sr_rpc_tree_cb)(sr_session_ctx_t *session, uint32_t sub_id, const char *op_path, const struct lyd_node *input,
-        sr_event_t event, uint32_t request_id, struct lyd_node *output, void *private_data);
+        sr_event_t event, uint32_t operation_id, struct lyd_node *output, void *private_data);
 
 /** @} rpcsubs */
 
@@ -680,7 +679,7 @@ typedef void (*sr_event_notif_tree_cb)(sr_session_ctx_t *session, uint32_t sub_i
  * @param[in] path [Path](@ref paths) identifying the subtree that is supposed to be provided, same as the one used
  * for the subscription.
  * @param[in] request_xpath [XPath](@ref paths) as requested by a client. Can be NULL.
- * @param[in] request_id Request ID unique for the specific @p module_name.
+ * @param[in] operation_id Operation ID of the current operation used for all the callbacks and events.
  * @param[in,out] parent Pointer to an existing parent of the requested nodes. Is NULL for top-level nodes.
  * Caller is supposed to append the requested nodes to this data subtree and return either the original parent
  * or a top-level node.
@@ -688,7 +687,7 @@ typedef void (*sr_event_notif_tree_cb)(sr_session_ctx_t *session, uint32_t sub_i
  * @return User error code (::SR_ERR_OK on success).
  */
 typedef int (*sr_oper_get_items_cb)(sr_session_ctx_t *session, uint32_t sub_id, const char *module_name, const char *path,
-        const char *request_xpath, uint32_t request_id, struct lyd_node **parent, void *private_data);
+        const char *request_xpath, uint32_t operation_id, struct lyd_node **parent, void *private_data);
 
 /** @} oper_subs */
 
diff --git a/tests/test_oper_pull.c b/tests/test_oper_pull.c
index 91ba526e..793a6456 100644
--- a/tests/test_oper_pull.c
+++ b/tests/test_oper_pull.c
@@ -974,8 +974,7 @@ enabled_change_cb(sr_session_ctx_t *session, uint32_t sub_id, const char *module
     int ret, *called = (int *)private_data;
 
     (void)sub_id;
-
-    assert_int_equal(request_id, 0);
+    (void)request_id;
 
     if (!strcmp(xpath, "/ietf-interfaces:interfaces/interface[name='eth128']")) {
         assert_string_equal(module_name, "ietf-interfaces");
-- 
2.43.0

